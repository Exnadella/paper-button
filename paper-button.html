<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
@group Quantum Paper Elements

`paper-button` is a button containing text or an image. When the user touches
the button, a ripple effect emanates from the point of contact.

A `paper-button` may be flat or raised. A raised button behaves like a piece
of paper resting on another sheet, and lifts up upon press. Flat buttons do
not raise up. Add the `raisedButton` attribute to make a raised button.

Example:

    <paper-button>flat button</paper-button>
    <paper-button raisedButton>raised button</paper-button>

A button should be styled with a background color, text color, ripple color
and hover color.

To style the background, text and hover color, apply the `background` and
`color` CSS properties to the button. To style the ripple color, apply the
`color` CSS property to the `#ripple` element in the button's shadow root:

    /* Style #my-button blue with white text and darker blue ink. */
    #my-button {
        background: #4285f4;
        color: #fff;
    }

    #my-button:hover {
        background: #2a56c6;
    }

    #my-button::shadow #ripple {
        color: #2a56c6;
    }

@class paper-button
@extends paper-focusable
-->

<link href="../polymer/polymer.html" rel="import">
<link href="../paper-focusable/paper-focusable.html" rel="import">
<link href="../paper-ripple/paper-ripple.html" rel="import">
<link href="../paper-shadow/paper-shadow.html" rel="import">

<polymer-element name="paper-button" extends="paper-focusable" attributes="inkColor raisedButton">

  <template>

    <link href="paper-button.css" rel="stylesheet">

    <paper-shadow id="shadow" z="{{z}}" animated></paper-shadow>

    <div id="clip">
      <div id="focusBg"></div>
      <paper-ripple id="ripple"></paper-ripple>
      <div id="content"><content></content></div>
    </div>

  </template>

  <script>
    Polymer('paper-button', {

      publish: {

        /**
         * If true, the button will be styled as a "raised" button.
         *
         * @attribute raisedButton
         * @type boolean
         * @default false
         */
        raisedButton: {value: false, reflect: true}

      },

      z: 1,

      raisedButtonChanged: function() {
        if (this.raisedButton) {
          this.$.shadow.target = this;
        } else {
          this.$.shadow.target = null;
        }
      },

      activeChanged: function() {
        this.super();
        this.adjustZ();

        // if (this.active) {
        //   this.$.ink.spill();
        // } else {
        //   this.waitForSpillCompleted('resetInk');
        // }
      },

      focusedChanged: function() {
        this.super();
        this.adjustZ();
      },

      disabledChanged: function() {
        this.super();
        this.adjustZ();
      },

      // waitForSpillCompleted: function(callback) {
      //   this.async(callback, null, (this.$.ink.spillCompleted ? 0 : this.duration));
      // },

      // resetInk: function() {
      //   this.active = false;
      //   this.$.ink.reset();
      // },

      insideButton: function(x, y) {
        var rect = this.getBoundingClientRect();
        return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
      },

      adjustZ: function() {
        if (this.focused) {
          this.classList.add('paper-shadow-animate-z-1-z-2');
        } else {
          this.classList.remove('paper-shadow-animate-z-1-z-2');

          if (this.active) {
            this.z = 2;
          } else if (this.disabled) {
            this.z = 0;
          } else {
            this.z = 1;
          }

        }
      },

      downAction: function(e) {
        this.super(e);
        this.$.ripple.downAction(e);
      },

      upAction: function(e) {
        this.super(e);
        this.$.ripple.upAction(e);
      }

      // tapAction: function() {
      //   if (this.disabled) {
      //     return;
      //   }

      //   if (!this.isToggle) {
      //     this.waitForSpillCompleted(function() {
      //       this.active = false;
      //       this.$.ink.evaporate();
      //     });
      //   }
      // },

      // downAction: function(e) {
      //   if (this.disabled) {
      //     return;
      //   }

      //   this.super();

      //   var rect = this.getBoundingClientRect();
      //   // We want the ink to propagate from the interaction point to the
      //   // furthest point within the container; giving a consistent duration, no
      //   // matter where the user interacts.
      //   var relativeX = (this.centerInk) ? rect.width  / 2 : e.x - rect.left;
      //   var relativeY = (this.centerInk) ? rect.height / 2 : e.y - rect.top;
      //   var maxX = Math.max(relativeX, rect.width - relativeX);
      //   var maxY = Math.max(relativeY, rect.height - relativeY);
      //   var inkDiameter = Math.sqrt(maxX * maxX + maxY * maxY) * 2;

      //   this.$.ink.style.height = inkDiameter + 'px';
      //   this.$.ink.style.width = inkDiameter + 'px';
      //   if (this.centerInk) {
      //     this.$.ink.style.left = (rect.width - inkDiameter) / 2 + 'px';
      //     this.$.ink.style.top = (rect.height - inkDiameter) / 2 + 'px';
      //   } else {
      //     this.$.ink.style.left = (e.x - rect.left - inkDiameter / 2) + 'px';
      //     this.$.ink.style.top = (e.y - rect.top - inkDiameter / 2) + 'px';
      //   }
      // }

    });
  </script>
</polymer-element>
