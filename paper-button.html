<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
/**
 * @module Quantum Paper Elements
 */
/**
 * paper-button
 *
 * Example:
 *
 *    <paper-button></paper-button>
 *
 * @class paper-button
 */
-->

<link href="../polymer/polymer.html" rel="import">
<link href="../paper-ink/paper-ink.html" rel="import">
<link href="../paper-shadow/paper-shadow.html" rel="import">

<polymer-element name="paper-button" attributes="inkColor centerInk raisedButton pressed focused disabled" tabindex="0" on-tap="{{tapAction}}" on-down="{{downAction}}" on-up="{{upAction}}" on-focus="{{focusAction}}" on-blur="{{blurAction}}">

  <template>

    <link href="paper-button.css" rel="stylesheet">

    <paper-shadow id="shadow" z="{{z}}" animated></paper-shadow>

    <div id="clip">
      <div id="focusBg"></div>
      <paper-ink id="ink" color="{{_inkColor}}"></paper-ink>
      <div><content></content></div>
    </div>

  </template>

  <script>
    (function() {

      var DEFAULT_INK_COLOR = '#d1d1d1';
      var DEFAULT_INK_COLOR_RAISED = '#cecece';

      Polymer('paper-button', {

        publish: {

          /**
           * The color of the ink that spreads when the button is tapped.
           *
           * @attribute inkColor
           * @type string
           */
          inkColor: {value: '', reflect: true},

          /**
           * If true, the ink will be centered in the button.
           *
           * @attribute centerInk
           * @type boolean
           * @default false
           */
          centerInk: {value: false, reflect: true},

          /**
           * If true, the button will be styled as a "raised" button.
           */
          raisedButton: {value: false, reflect: true},

          /**
           * If true, the user is currently holding down the button.
           *
           * @attribute pressed
           * @type boolean
           * @default false
           */
          pressed: {value: false, reflect: true},

          /**
           * If true, the button currently has focus.
           *
           * @attribute focused
           * @type boolean
           * @default false
           */
          focused: {value: false, reflect: true},

          /**
           * If true, the user cannot interact with this button.
           *
           * @attribute disabled
           * @type boolean
           * @default false
           */
          disabled: {value: false, reflect: true}

        },

        observe: {
          focused: 'adjustZ',
          pressed: 'adjustZ'
        },

        z: 1,
        _inkColor: '',

        raisedButtonChanged: function() {
          if (this.raisedButton) {
            this.$.shadow.target = this;
            this._inkColor = this.inkColor || DEFAULT_INK_COLOR_RAISED;
          } else {
            this.$.shadow.target = null;
            this._inkColor = this.inkColor || DEFAULT_INK_COLOR;
          }
        },

        disabledChanged: function() {
          if (this.disabled) {
            this.removeAttribute('tabindex');
          } else {
            this.setAttribute('tabindex', 0);
          }
          this.adjustZ();
        },

        waitForSpillCompleted: function(callback) {
          this.async(callback, null, (this.$.ink.spillCompleted ? 0 : this.duration));
        },

        resetInk: function() {
          this.pressed = false;
          this.$.ink.reset();
        },

        insideButton: function(x, y) {
          var rect = this.getBoundingClientRect();
          return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },

        adjustZ: function() {
          if (this.focused) {
            this.classList.add('paper-shadow-animate-z-1-z-2');
          } else {
            this.classList.remove('paper-shadow-animate-z-1-z-2');

            if (this.pressed) {
              this.z = 2;
            } else if (this.disabled) {
              this.z = 0;
            } else {
              this.z = 1;
            }

          }
        },

        tapAction: function() {
          if (this.disabled) {
            return;
          }

          this.waitForSpillCompleted(function() {
            this.pressed = false;
            this.$.ink.evaporate();
          });
        },

        downAction: function(e) {
          if (this.disabled) {
            return;
          }

          this.pressed = true;

          var rect = this.getBoundingClientRect();
          // We want the ink to propagate from the interaction point to the
          // furthest point within the container; giving a consistent duration, no
          // matter where the user interacts.
          var relativeX = (this.centerInk) ? rect.width  / 2 : e.x - rect.left;
          var relativeY = (this.centerInk) ? rect.height / 2 : e.y - rect.top;
          var maxX = Math.max(relativeX, rect.width - relativeX);
          var maxY = Math.max(relativeY, rect.height - relativeY);
          var inkDiameter = Math.sqrt(maxX * maxX + maxY * maxY) * 2;

          this.$.ink.style.height = inkDiameter + 'px';
          this.$.ink.style.width = inkDiameter + 'px';
          if (this.centerInk) {
            this.$.ink.style.left = (rect.width - inkDiameter) / 2 + 'px';
            this.$.ink.style.top = (rect.height - inkDiameter) / 2 + 'px';
          } else {
            this.$.ink.style.left = (e.x - rect.left - inkDiameter / 2) + 'px';
            this.$.ink.style.top = (e.y - rect.top - inkDiameter / 2) + 'px';
          }
          this.$.ink.spill();
        },

        upAction: function(e) {
          if (this.disabled) {
            return;
          }

          // wait for tap event to reset ink
          if (this.insideButton(e.x, e.y)) {
            return;
          }

          this.pressed = false;

          this.waitForSpillCompleted('resetInk');
        },

        focusAction: function() {
          if (!this.pressed) {
            // Only render the "focused" state if the element gains focus due to
            // keyboard navigation.
            this.focused = true;
          }
        },

        blurAction: function() {
          this.focused = false;
        }

      });

    })();
  </script>
</polymer-element>
